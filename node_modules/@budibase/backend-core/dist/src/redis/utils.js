"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.removeDbPrefix = exports.addDbPrefix = exports.getRedisOptions = exports.SelectableDatabase = exports.Databases = exports.SEPARATOR = void 0;
const environment_1 = __importDefault(require("../environment"));
const SLOT_REFRESH_MS = 2000;
const CONNECT_TIMEOUT_MS = 10000;
const REDIS_URL = !environment_1.default.REDIS_URL ? "localhost:6379" : environment_1.default.REDIS_URL;
const REDIS_PASSWORD = !environment_1.default.REDIS_PASSWORD ? "budibase" : environment_1.default.REDIS_PASSWORD;
exports.SEPARATOR = "-";
/**
 * These Redis databases help us to segment up a Redis keyspace by prepending the
 * specified database name onto the cache key. This means that a single real Redis database
 * can be split up a bit; allowing us to use scans on small databases to find some particular
 * keys within.
 * If writing a very large volume of keys is expected (say 10K+) then it is better to keep these out
 * of the default keyspace and use a separate one - the SelectableDatabase can be used for this.
 */
var Databases;
(function (Databases) {
    Databases["PW_RESETS"] = "pwReset";
    Databases["VERIFICATIONS"] = "verification";
    Databases["INVITATIONS"] = "invitation";
    Databases["DEV_LOCKS"] = "devLocks";
    Databases["DEBOUNCE"] = "debounce";
    Databases["SESSIONS"] = "session";
    Databases["USER_CACHE"] = "users";
    Databases["FLAGS"] = "flags";
    Databases["APP_METADATA"] = "appMetadata";
    Databases["QUERY_VARS"] = "queryVars";
    Databases["LICENSES"] = "license";
    Databases["GENERIC_CACHE"] = "data_cache";
    Databases["WRITE_THROUGH"] = "writeThrough";
    Databases["LOCKS"] = "locks";
})(Databases = exports.Databases || (exports.Databases = {}));
/**
 * These define the numeric Redis databases that can be access with the SELECT command -
 * (https://redis.io/commands/select/). By default a Redis server/cluster will have 16 selectable
 * databases, increasing this count increases the amount of CPU/memory required to run the server.
 * Ideally new Redis keyspaces should be used sparingly, only when absolutely necessary for performance
 * to be maintained. Generally a keyspace can grow to be very large is scans are not needed or desired,
 * but if you need to walk through all values in a database periodically then a separate selectable
 * keyspace should be used.
 */
var SelectableDatabase;
(function (SelectableDatabase) {
    SelectableDatabase[SelectableDatabase["DEFAULT"] = 0] = "DEFAULT";
    SelectableDatabase[SelectableDatabase["WRITE_THROUGH"] = 1] = "WRITE_THROUGH";
    SelectableDatabase[SelectableDatabase["UNUSED_1"] = 2] = "UNUSED_1";
    SelectableDatabase[SelectableDatabase["UNUSED_2"] = 3] = "UNUSED_2";
    SelectableDatabase[SelectableDatabase["UNUSED_3"] = 4] = "UNUSED_3";
    SelectableDatabase[SelectableDatabase["UNUSED_4"] = 5] = "UNUSED_4";
    SelectableDatabase[SelectableDatabase["UNUSED_5"] = 6] = "UNUSED_5";
    SelectableDatabase[SelectableDatabase["UNUSED_6"] = 7] = "UNUSED_6";
    SelectableDatabase[SelectableDatabase["UNUSED_7"] = 8] = "UNUSED_7";
    SelectableDatabase[SelectableDatabase["UNUSED_8"] = 9] = "UNUSED_8";
    SelectableDatabase[SelectableDatabase["UNUSED_9"] = 10] = "UNUSED_9";
    SelectableDatabase[SelectableDatabase["UNUSED_10"] = 11] = "UNUSED_10";
    SelectableDatabase[SelectableDatabase["UNUSED_11"] = 12] = "UNUSED_11";
    SelectableDatabase[SelectableDatabase["UNUSED_12"] = 13] = "UNUSED_12";
    SelectableDatabase[SelectableDatabase["UNUSED_13"] = 14] = "UNUSED_13";
    SelectableDatabase[SelectableDatabase["UNUSED_14"] = 15] = "UNUSED_14";
})(SelectableDatabase = exports.SelectableDatabase || (exports.SelectableDatabase = {}));
function getRedisOptions(clustered = false) {
    let password = REDIS_PASSWORD;
    let url = REDIS_URL.split("//");
    // get rid of the protocol
    url = url.length > 1 ? url[1] : url[0];
    // check for a password etc
    url = url.split("@");
    if (url.length > 1) {
        // get the password
        password = url[0].split(":")[1];
        url = url[1];
    }
    else {
        url = url[0];
    }
    const [host, port] = url.split(":");
    let redisProtocolUrl;
    // fully qualified redis URL
    if (/rediss?:\/\//.test(REDIS_URL)) {
        redisProtocolUrl = REDIS_URL;
    }
    const opts = {
        connectTimeout: CONNECT_TIMEOUT_MS,
    };
    if (clustered) {
        opts.redisOptions = {};
        opts.redisOptions.tls = {};
        opts.redisOptions.password = password;
        opts.slotsRefreshTimeout = SLOT_REFRESH_MS;
        opts.dnsLookup = (address, callback) => callback(null, address);
    }
    else {
        opts.host = host;
        opts.port = port;
        opts.password = password;
    }
    return { opts, host, port, redisProtocolUrl };
}
exports.getRedisOptions = getRedisOptions;
function addDbPrefix(db, key) {
    if (key.includes(db)) {
        return key;
    }
    return `${db}${exports.SEPARATOR}${key}`;
}
exports.addDbPrefix = addDbPrefix;
function removeDbPrefix(key) {
    let parts = key.split(exports.SEPARATOR);
    if (parts.length >= 2) {
        parts.shift();
        return parts.join(exports.SEPARATOR);
    }
    else {
        // return the only part
        return parts[0];
    }
}
exports.removeDbPrefix = removeDbPrefix;
//# sourceMappingURL=utils.js.map