"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getScopedConfig = exports.pagination = exports.getPlatformUrl = exports.getScopedFullConfig = exports.getPluginParams = exports.generatePluginID = exports.generateDevInfoID = exports.getConfigParams = exports.generateConfigID = exports.dbExists = exports.getDevAppIDs = exports.getProdAppIDs = exports.getAllApps = exports.getAllDbs = exports.getStartEndKeyURL = exports.getRoleParams = exports.generateRoleID = exports.getTemplateParams = exports.generateAppUserID = exports.generateTemplateID = exports.getUsersByAppParams = exports.getGlobalIDFromUserMetadataID = exports.generateUserMetadataID = exports.getUserMetadataParams = exports.getGlobalUserParams = exports.generateGlobalUserID = exports.getWorkspaceParams = exports.generateWorkspaceID = exports.isDatasourceId = exports.isTableId = exports.generateRowID = exports.getQueryIndex = exports.getRowParams = exports.getDocParams = exports.generateAppID = void 0;
const newid_1 = require("../newid");
const environment_1 = __importDefault(require("../environment"));
const constants_1 = require("../constants");
const context_1 = require("../context");
const db_1 = require("./db");
const appMetadata_1 = require("../cache/appMetadata");
const conversions_1 = require("./conversions");
const events = __importStar(require("../events"));
const types_1 = require("@budibase/types");
/**
 * Generates a new app ID.
 * @returns {string} The new app ID which the app doc can be stored under.
 */
const generateAppID = (tenantId) => {
    let id = constants_1.APP_PREFIX;
    if (tenantId) {
        id += `${tenantId}${constants_1.SEPARATOR}`;
    }
    return `${id}${(0, newid_1.newid)()}`;
};
exports.generateAppID = generateAppID;
/**
 * If creating DB allDocs/query params with only a single top level ID this can be used, this
 * is usually the case as most of our docs are top level e.g. tables, automations, users and so on.
 * More complex cases such as link docs and rows which have multiple levels of IDs that their
 * ID consists of need their own functions to build the allDocs parameters.
 * @param {string} docType The type of document which input params are being built for, e.g. user,
 * link, app, table and so on.
 * @param {string|null} docId The ID of the document minus its type - this is only needed if looking
 * for a singular document.
 * @param {object} otherProps Add any other properties onto the request, e.g. include_docs.
 * @returns {object} Parameters which can then be used with an allDocs request.
 */
function getDocParams(docType, docId, otherProps = {}) {
    if (docId == null) {
        docId = "";
    }
    return Object.assign(Object.assign({}, otherProps), { startkey: `${docType}${constants_1.SEPARATOR}${docId}`, endkey: `${docType}${constants_1.SEPARATOR}${docId}${constants_1.UNICODE_MAX}` });
}
exports.getDocParams = getDocParams;
/**
 * Gets the DB allDocs/query params for retrieving a row.
 * @param {string|null} tableId The table in which the rows have been stored.
 * @param {string|null} rowId The ID of the row which is being specifically queried for. This can be
 * left null to get all the rows in the table.
 * @param {object} otherProps Any other properties to add to the request.
 * @returns {object} Parameters which can then be used with an allDocs request.
 */
function getRowParams(tableId, rowId, otherProps = {}) {
    if (tableId == null) {
        return getDocParams(constants_1.DocumentType.ROW, null, otherProps);
    }
    const endOfKey = rowId == null ? `${tableId}${constants_1.SEPARATOR}` : rowId;
    return getDocParams(constants_1.DocumentType.ROW, endOfKey, otherProps);
}
exports.getRowParams = getRowParams;
/**
 * Retrieve the correct index for a view based on default design DB.
 */
function getQueryIndex(viewName) {
    return `database/${viewName}`;
}
exports.getQueryIndex = getQueryIndex;
/**
 * Gets a new row ID for the specified table.
 * @param {string} tableId The table which the row is being created for.
 * @param {string|null} id If an ID is to be used then the UUID can be substituted for this.
 * @returns {string} The new ID which a row doc can be stored under.
 */
function generateRowID(tableId, id) {
    id = id || (0, newid_1.newid)();
    return `${constants_1.DocumentType.ROW}${constants_1.SEPARATOR}${tableId}${constants_1.SEPARATOR}${id}`;
}
exports.generateRowID = generateRowID;
/**
 * Check if a given ID is that of a table.
 * @returns {boolean}
 */
const isTableId = (id) => {
    // this includes datasource plus tables
    return (id &&
        (id.startsWith(`${constants_1.DocumentType.TABLE}${constants_1.SEPARATOR}`) ||
            id.startsWith(`${constants_1.DocumentType.DATASOURCE_PLUS}${constants_1.SEPARATOR}`)));
};
exports.isTableId = isTableId;
/**
 * Check if a given ID is that of a datasource or datasource plus.
 * @returns {boolean}
 */
const isDatasourceId = (id) => {
    // this covers both datasources and datasource plus
    return id && id.startsWith(`${constants_1.DocumentType.DATASOURCE}${constants_1.SEPARATOR}`);
};
exports.isDatasourceId = isDatasourceId;
/**
 * Generates a new workspace ID.
 * @returns {string} The new workspace ID which the workspace doc can be stored under.
 */
function generateWorkspaceID() {
    return `${constants_1.DocumentType.WORKSPACE}${constants_1.SEPARATOR}${(0, newid_1.newid)()}`;
}
exports.generateWorkspaceID = generateWorkspaceID;
/**
 * Gets parameters for retrieving workspaces.
 */
function getWorkspaceParams(id = "", otherProps = {}) {
    return Object.assign(Object.assign({}, otherProps), { startkey: `${constants_1.DocumentType.WORKSPACE}${constants_1.SEPARATOR}${id}`, endkey: `${constants_1.DocumentType.WORKSPACE}${constants_1.SEPARATOR}${id}${constants_1.UNICODE_MAX}` });
}
exports.getWorkspaceParams = getWorkspaceParams;
/**
 * Generates a new global user ID.
 * @returns {string} The new user ID which the user doc can be stored under.
 */
function generateGlobalUserID(id) {
    return `${constants_1.DocumentType.USER}${constants_1.SEPARATOR}${id || (0, newid_1.newid)()}`;
}
exports.generateGlobalUserID = generateGlobalUserID;
/**
 * Gets parameters for retrieving users.
 */
function getGlobalUserParams(globalId, otherProps = {}) {
    if (!globalId) {
        globalId = "";
    }
    const startkey = otherProps === null || otherProps === void 0 ? void 0 : otherProps.startkey;
    return Object.assign(Object.assign({}, otherProps), { 
        // need to include this incase pagination
        startkey: startkey
            ? startkey
            : `${constants_1.DocumentType.USER}${constants_1.SEPARATOR}${globalId}`, endkey: `${constants_1.DocumentType.USER}${constants_1.SEPARATOR}${globalId}${constants_1.UNICODE_MAX}` });
}
exports.getGlobalUserParams = getGlobalUserParams;
/**
 * Gets parameters for retrieving users, this is a utility function for the getDocParams function.
 */
function getUserMetadataParams(userId, otherProps = {}) {
    return getRowParams(constants_1.InternalTable.USER_METADATA, userId, otherProps);
}
exports.getUserMetadataParams = getUserMetadataParams;
/**
 * Generates a new user ID based on the passed in global ID.
 * @param {string} globalId The ID of the global user.
 * @returns {string} The new user ID which the user doc can be stored under.
 */
function generateUserMetadataID(globalId) {
    return generateRowID(constants_1.InternalTable.USER_METADATA, globalId);
}
exports.generateUserMetadataID = generateUserMetadataID;
/**
 * Breaks up the ID to get the global ID.
 */
function getGlobalIDFromUserMetadataID(id) {
    const prefix = `${constants_1.DocumentType.ROW}${constants_1.SEPARATOR}${constants_1.InternalTable.USER_METADATA}${constants_1.SEPARATOR}`;
    if (!id || !id.includes(prefix)) {
        return id;
    }
    return id.split(prefix)[1];
}
exports.getGlobalIDFromUserMetadataID = getGlobalIDFromUserMetadataID;
function getUsersByAppParams(appId, otherProps = {}) {
    const prodAppId = (0, conversions_1.getProdAppID)(appId);
    return Object.assign(Object.assign({}, otherProps), { startkey: prodAppId, endkey: `${prodAppId}${constants_1.UNICODE_MAX}` });
}
exports.getUsersByAppParams = getUsersByAppParams;
/**
 * Generates a template ID.
 * @param ownerId The owner/user of the template, this could be global or a workspace level.
 */
function generateTemplateID(ownerId) {
    return `${constants_1.DocumentType.TEMPLATE}${constants_1.SEPARATOR}${ownerId}${constants_1.SEPARATOR}${(0, newid_1.newid)()}`;
}
exports.generateTemplateID = generateTemplateID;
function generateAppUserID(prodAppId, userId) {
    return `${prodAppId}${constants_1.SEPARATOR}${userId}`;
}
exports.generateAppUserID = generateAppUserID;
/**
 * Gets parameters for retrieving templates. Owner ID must be specified, either global or a workspace level.
 */
function getTemplateParams(ownerId, templateId, otherProps = {}) {
    if (!templateId) {
        templateId = "";
    }
    let final;
    if (templateId) {
        final = templateId;
    }
    else {
        final = `${constants_1.DocumentType.TEMPLATE}${constants_1.SEPARATOR}${ownerId}${constants_1.SEPARATOR}`;
    }
    return Object.assign(Object.assign({}, otherProps), { startkey: final, endkey: `${final}${constants_1.UNICODE_MAX}` });
}
exports.getTemplateParams = getTemplateParams;
/**
 * Generates a new role ID.
 * @returns {string} The new role ID which the role doc can be stored under.
 */
function generateRoleID(id) {
    return `${constants_1.DocumentType.ROLE}${constants_1.SEPARATOR}${id || (0, newid_1.newid)()}`;
}
exports.generateRoleID = generateRoleID;
/**
 * Gets parameters for retrieving a role, this is a utility function for the getDocParams function.
 */
function getRoleParams(roleId, otherProps = {}) {
    return getDocParams(constants_1.DocumentType.ROLE, roleId, otherProps);
}
exports.getRoleParams = getRoleParams;
function getStartEndKeyURL(baseKey, tenantId) {
    const tenancy = tenantId ? `${constants_1.SEPARATOR}${tenantId}` : "";
    return `startkey="${baseKey}${tenancy}"&endkey="${baseKey}${tenancy}${constants_1.UNICODE_MAX}"`;
}
exports.getStartEndKeyURL = getStartEndKeyURL;
/**
 * if in production this will use the CouchDB _all_dbs call to retrieve a list of databases. If testing
 * when using Pouch it will use the pouchdb-all-dbs package.
 * opts.efficient can be provided to make sure this call is always quick in a multi-tenant environment,
 * but it may not be 100% accurate in full efficiency mode (some tenantless apps may be missed).
 */
function getAllDbs(opts = { efficient: false }) {
    return __awaiter(this, void 0, void 0, function* () {
        const efficient = opts && opts.efficient;
        // specifically for testing we use the pouch package for this
        if (environment_1.default.isTest()) {
            return (0, db_1.allDbs)();
        }
        let dbs = [];
        function addDbs(queryString) {
            return __awaiter(this, void 0, void 0, function* () {
                const json = yield (0, db_1.directCouchAllDbs)(queryString);
                dbs = dbs.concat(json);
            });
        }
        let tenantId = (0, context_1.getTenantId)();
        if (!environment_1.default.MULTI_TENANCY || (!efficient && tenantId === constants_1.DEFAULT_TENANT_ID)) {
            // just get all DBs when:
            // - single tenancy
            // - default tenant
            //    - apps dbs don't contain tenant id
            //    - non-default tenant dbs are filtered out application side in getAllApps
            yield addDbs();
        }
        else {
            // get prod apps
            yield addDbs(getStartEndKeyURL(constants_1.DocumentType.APP, tenantId));
            // get dev apps
            yield addDbs(getStartEndKeyURL(constants_1.DocumentType.APP_DEV, tenantId));
            // add global db name
            dbs.push((0, context_1.getGlobalDBName)(tenantId));
        }
        return dbs;
    });
}
exports.getAllDbs = getAllDbs;
/**
 * Lots of different points in the system need to find the full list of apps, this will
 * enumerate the entire CouchDB cluster and get the list of databases (every app).
 *
 * @return {Promise<object[]>} returns the app information document stored in each app database.
 */
function getAllApps({ dev, all, idsOnly, efficient, } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
        let tenantId = (0, context_1.getTenantId)();
        if (!environment_1.default.MULTI_TENANCY && !tenantId) {
            tenantId = constants_1.DEFAULT_TENANT_ID;
        }
        let dbs = yield getAllDbs({ efficient });
        const appDbNames = dbs.filter((dbName) => {
            if (environment_1.default.isTest() && !dbName) {
                return false;
            }
            const split = dbName.split(constants_1.SEPARATOR);
            // it is an app, check the tenantId
            if (split[0] === constants_1.DocumentType.APP) {
                // tenantId is always right before the UUID
                const possibleTenantId = split[split.length - 2];
                const noTenantId = split.length === 2 || possibleTenantId === constants_1.DocumentType.DEV;
                return ((tenantId === constants_1.DEFAULT_TENANT_ID && noTenantId) ||
                    possibleTenantId === tenantId);
            }
            return false;
        });
        if (idsOnly) {
            const devAppIds = appDbNames.filter(appId => (0, conversions_1.isDevAppID)(appId));
            const prodAppIds = appDbNames.filter(appId => !(0, conversions_1.isDevAppID)(appId));
            switch (dev) {
                case true:
                    return devAppIds;
                case false:
                    return prodAppIds;
                default:
                    return appDbNames;
            }
        }
        const appPromises = appDbNames.map((app) => 
        // skip setup otherwise databases could be re-created
        (0, appMetadata_1.getAppMetadata)(app));
        if (appPromises.length === 0) {
            return [];
        }
        else {
            const response = yield Promise.allSettled(appPromises);
            const apps = response
                .filter((result) => result.status === "fulfilled" && result.value != null)
                .map(({ value }) => value);
            if (!all) {
                return apps.filter((app) => {
                    if (dev) {
                        return (0, conversions_1.isDevApp)(app);
                    }
                    return !(0, conversions_1.isDevApp)(app);
                });
            }
            else {
                return apps.map((app) => (Object.assign(Object.assign({}, app), { status: (0, conversions_1.isDevApp)(app) ? "development" : "published" })));
            }
        }
    });
}
exports.getAllApps = getAllApps;
/**
 * Utility function for getAllApps but filters to production apps only.
 */
function getProdAppIDs() {
    return __awaiter(this, void 0, void 0, function* () {
        const apps = (yield getAllApps({ idsOnly: true }));
        return apps.filter((id) => !(0, conversions_1.isDevAppID)(id));
    });
}
exports.getProdAppIDs = getProdAppIDs;
/**
 * Utility function for the inverse of above.
 */
function getDevAppIDs() {
    return __awaiter(this, void 0, void 0, function* () {
        const apps = (yield getAllApps({ idsOnly: true }));
        return apps.filter((id) => (0, conversions_1.isDevAppID)(id));
    });
}
exports.getDevAppIDs = getDevAppIDs;
function dbExists(dbName) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, db_1.doWithDB)(dbName, (db) => __awaiter(this, void 0, void 0, function* () {
            return yield db.exists();
        }), { skip_setup: true });
    });
}
exports.dbExists = dbExists;
/**
 * Generates a new configuration ID.
 * @returns {string} The new configuration ID which the config doc can be stored under.
 */
const generateConfigID = ({ type, workspace, user }) => {
    const scope = [type, workspace, user].filter(Boolean).join(constants_1.SEPARATOR);
    return `${constants_1.DocumentType.CONFIG}${constants_1.SEPARATOR}${scope}`;
};
exports.generateConfigID = generateConfigID;
/**
 * Gets parameters for retrieving configurations.
 */
const getConfigParams = ({ type, workspace, user }, otherProps = {}) => {
    const scope = [type, workspace, user].filter(Boolean).join(constants_1.SEPARATOR);
    return Object.assign(Object.assign({}, otherProps), { startkey: `${constants_1.DocumentType.CONFIG}${constants_1.SEPARATOR}${scope}`, endkey: `${constants_1.DocumentType.CONFIG}${constants_1.SEPARATOR}${scope}${constants_1.UNICODE_MAX}` });
};
exports.getConfigParams = getConfigParams;
/**
 * Generates a new dev info document ID - this is scoped to a user.
 * @returns {string} The new dev info ID which info for dev (like api key) can be stored under.
 */
const generateDevInfoID = (userId) => {
    return `${constants_1.DocumentType.DEV_INFO}${constants_1.SEPARATOR}${userId}`;
};
exports.generateDevInfoID = generateDevInfoID;
/**
 * Generates a new plugin ID - to be used in the global DB.
 * @returns {string} The new plugin ID which a plugin metadata document can be stored under.
 */
const generatePluginID = (name) => {
    return `${constants_1.DocumentType.PLUGIN}${constants_1.SEPARATOR}${name}`;
};
exports.generatePluginID = generatePluginID;
/**
 * Gets parameters for retrieving automations, this is a utility function for the getDocParams function.
 */
const getPluginParams = (pluginId, otherProps = {}) => {
    return getDocParams(constants_1.DocumentType.PLUGIN, pluginId, otherProps);
};
exports.getPluginParams = getPluginParams;
/**
 * Returns the most granular configuration document from the DB based on the type, workspace and userID passed.
 * @param {Object} db - db instance to query
 * @param {Object} scopes - the type, workspace and userID scopes of the configuration.
 * @returns The most granular configuration document based on the scope.
 */
const getScopedFullConfig = function (db, { type, user, workspace }) {
    return __awaiter(this, void 0, void 0, function* () {
        const response = yield db.allDocs((0, exports.getConfigParams)({ type, user, workspace }, {
            include_docs: true,
        }));
        function determineScore(row) {
            const config = row.doc;
            // Config is specific to a user and a workspace
            if (config._id.includes((0, exports.generateConfigID)({ type, user, workspace }))) {
                return 4;
            }
            else if (config._id.includes((0, exports.generateConfigID)({ type, user }))) {
                // Config is specific to a user only
                return 3;
            }
            else if (config._id.includes((0, exports.generateConfigID)({ type, workspace }))) {
                // Config is specific to a workspace only
                return 2;
            }
            else if (config._id.includes((0, exports.generateConfigID)({ type }))) {
                // Config is specific to a type only
                return 1;
            }
            return 0;
        }
        // Find the config with the most granular scope based on context
        let scopedConfig = response.rows.sort((a, b) => determineScore(a) - determineScore(b))[0];
        // custom logic for settings doc
        if (type === types_1.ConfigType.SETTINGS) {
            if (scopedConfig && scopedConfig.doc) {
                // overrides affected by environment variables
                scopedConfig.doc.config.platformUrl = yield (0, exports.getPlatformUrl)({
                    tenantAware: true,
                });
                scopedConfig.doc.config.analyticsEnabled =
                    yield events.analytics.enabled();
            }
            else {
                // defaults
                scopedConfig = {
                    doc: {
                        _id: (0, exports.generateConfigID)({ type, user, workspace }),
                        config: {
                            platformUrl: yield (0, exports.getPlatformUrl)({ tenantAware: true }),
                            analyticsEnabled: yield events.analytics.enabled(),
                        },
                    },
                };
            }
        }
        return scopedConfig && scopedConfig.doc;
    });
};
exports.getScopedFullConfig = getScopedFullConfig;
const getPlatformUrl = (opts = { tenantAware: true }) => __awaiter(void 0, void 0, void 0, function* () {
    let platformUrl = environment_1.default.PLATFORM_URL || "http://localhost:10000";
    if (!environment_1.default.SELF_HOSTED && environment_1.default.MULTI_TENANCY && opts.tenantAware) {
        // cloud and multi tenant - add the tenant to the default platform url
        const tenantId = (0, context_1.getTenantId)();
        if (!platformUrl.includes("localhost:")) {
            platformUrl = platformUrl.replace("://", `://${tenantId}.`);
        }
    }
    else if (environment_1.default.SELF_HOSTED) {
        const db = (0, context_1.getGlobalDB)();
        // get the doc directly instead of with getScopedConfig to prevent loop
        let settings;
        try {
            settings = yield db.get((0, exports.generateConfigID)({ type: types_1.ConfigType.SETTINGS }));
        }
        catch (e) {
            if (e.status !== 404) {
                throw e;
            }
        }
        // self hosted - check for platform url override
        if (settings && settings.config && settings.config.platformUrl) {
            platformUrl = settings.config.platformUrl;
        }
    }
    return platformUrl;
});
exports.getPlatformUrl = getPlatformUrl;
function pagination(data, pageSize, { paginate, property, getKey, } = {
    paginate: true,
    property: "_id",
}) {
    if (!paginate) {
        return { data, hasNextPage: false };
    }
    const hasNextPage = data.length > pageSize;
    let nextPage = undefined;
    if (!getKey) {
        getKey = (doc) => (property ? doc === null || doc === void 0 ? void 0 : doc[property] : doc === null || doc === void 0 ? void 0 : doc._id);
    }
    if (hasNextPage) {
        nextPage = getKey(data[pageSize]);
    }
    return {
        data: data.slice(0, pageSize),
        hasNextPage,
        nextPage,
    };
}
exports.pagination = pagination;
function getScopedConfig(db, params) {
    return __awaiter(this, void 0, void 0, function* () {
        const configDoc = yield (0, exports.getScopedFullConfig)(db, params);
        return configDoc && configDoc.config ? configDoc.config : configDoc;
    });
}
exports.getScopedConfig = getScopedConfig;
//# sourceMappingURL=utils.js.map