"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTenantIDFromCtx = exports.getTenantIds = exports.isUserInAppTenant = exports.getTenantUser = exports.lookupTenantId = exports.doWithGlobalDB = exports.tryAddTenant = exports.doesTenantExist = exports.addTenantToUrl = void 0;
const db_1 = require("../db");
const context_1 = require("../context");
const environment_1 = __importDefault(require("../environment"));
const types_1 = require("@budibase/types");
const constants_1 = require("../constants");
const TENANT_DOC = constants_1.StaticDatabases.PLATFORM_INFO.docs.tenants;
const PLATFORM_INFO_DB = constants_1.StaticDatabases.PLATFORM_INFO.name;
function addTenantToUrl(url) {
    const tenantId = (0, context_1.getTenantId)();
    if ((0, context_1.isMultiTenant)()) {
        const char = url.indexOf("?") === -1 ? "?" : "&";
        url += `${char}tenantId=${tenantId}`;
    }
    return url;
}
exports.addTenantToUrl = addTenantToUrl;
function doesTenantExist(tenantId) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, db_1.doWithDB)(PLATFORM_INFO_DB, (db) => __awaiter(this, void 0, void 0, function* () {
            let tenants;
            try {
                tenants = yield db.get(TENANT_DOC);
            }
            catch (err) {
                // if theres an error the doc doesn't exist, no tenants exist
                return false;
            }
            return (tenants &&
                Array.isArray(tenants.tenantIds) &&
                tenants.tenantIds.indexOf(tenantId) !== -1);
        }));
    });
}
exports.doesTenantExist = doesTenantExist;
function tryAddTenant(tenantId, userId, email, afterCreateTenant) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, db_1.doWithDB)(PLATFORM_INFO_DB, (db) => __awaiter(this, void 0, void 0, function* () {
            const getDoc = (id) => __awaiter(this, void 0, void 0, function* () {
                if (!id) {
                    return null;
                }
                try {
                    return yield db.get(id);
                }
                catch (err) {
                    return { _id: id };
                }
            });
            let [tenants, userIdDoc, emailDoc] = yield Promise.all([
                getDoc(TENANT_DOC),
                getDoc(userId),
                getDoc(email),
            ]);
            if (!Array.isArray(tenants.tenantIds)) {
                tenants = {
                    _id: TENANT_DOC,
                    tenantIds: [],
                };
            }
            let promises = [];
            if (userIdDoc) {
                userIdDoc.tenantId = tenantId;
                promises.push(db.put(userIdDoc));
            }
            if (emailDoc) {
                emailDoc.tenantId = tenantId;
                emailDoc.userId = userId;
                promises.push(db.put(emailDoc));
            }
            if (tenants.tenantIds.indexOf(tenantId) === -1) {
                tenants.tenantIds.push(tenantId);
                promises.push(db.put(tenants));
                yield afterCreateTenant();
            }
            yield Promise.all(promises);
        }));
    });
}
exports.tryAddTenant = tryAddTenant;
function doWithGlobalDB(tenantId, cb) {
    return (0, db_1.doWithDB)((0, db_1.getGlobalDBName)(tenantId), cb);
}
exports.doWithGlobalDB = doWithGlobalDB;
function lookupTenantId(userId) {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, db_1.doWithDB)(constants_1.StaticDatabases.PLATFORM_INFO.name, (db) => __awaiter(this, void 0, void 0, function* () {
            let tenantId = environment_1.default.MULTI_TENANCY ? context_1.DEFAULT_TENANT_ID : null;
            try {
                const doc = yield db.get(userId);
                if (doc && doc.tenantId) {
                    tenantId = doc.tenantId;
                }
            }
            catch (err) {
                // just return the default
            }
            return tenantId;
        }));
    });
}
exports.lookupTenantId = lookupTenantId;
// lookup, could be email or userId, either will return a doc
function getTenantUser(identifier) {
    return __awaiter(this, void 0, void 0, function* () {
        // use the view here and allow to find anyone regardless of casing
        // Use lowercase to ensure email login is case-insensitive
        const users = yield (0, db_1.queryPlatformView)(constants_1.ViewName.PLATFORM_USERS_LOWERCASE, {
            keys: [identifier.toLowerCase()],
            include_docs: true,
        });
        if (Array.isArray(users)) {
            return users[0];
        }
        else {
            return users;
        }
    });
}
exports.getTenantUser = getTenantUser;
function isUserInAppTenant(appId, user) {
    let userTenantId;
    if (user) {
        userTenantId = user.tenantId || context_1.DEFAULT_TENANT_ID;
    }
    else {
        userTenantId = (0, context_1.getTenantId)();
    }
    const tenantId = (0, context_1.getTenantIDFromAppID)(appId) || context_1.DEFAULT_TENANT_ID;
    return tenantId === userTenantId;
}
exports.isUserInAppTenant = isUserInAppTenant;
function getTenantIds() {
    return __awaiter(this, void 0, void 0, function* () {
        return (0, db_1.doWithDB)(PLATFORM_INFO_DB, (db) => __awaiter(this, void 0, void 0, function* () {
            let tenants;
            try {
                tenants = yield db.get(TENANT_DOC);
            }
            catch (err) {
                // if theres an error the doc doesn't exist, no tenants exist
                return [];
            }
            return (tenants && tenants.tenantIds) || [];
        }));
    });
}
exports.getTenantIds = getTenantIds;
const ALL_STRATEGIES = Object.values(types_1.TenantResolutionStrategy);
const getTenantIDFromCtx = (ctx, opts) => {
    var _a;
    // exit early if not multi-tenant
    if (!(0, context_1.isMultiTenant)()) {
        return context_1.DEFAULT_TENANT_ID;
    }
    // opt defaults
    if (opts.allowNoTenant === undefined) {
        opts.allowNoTenant = false;
    }
    if (!opts.includeStrategies) {
        opts.includeStrategies = ALL_STRATEGIES;
    }
    if (!opts.excludeStrategies) {
        opts.excludeStrategies = [];
    }
    const isAllowed = (strategy) => {
        var _a, _b;
        // excluded takes precedence
        if ((_a = opts.excludeStrategies) === null || _a === void 0 ? void 0 : _a.includes(strategy)) {
            return false;
        }
        if ((_b = opts.includeStrategies) === null || _b === void 0 ? void 0 : _b.includes(strategy)) {
            return true;
        }
    };
    // always use user first
    if (isAllowed(types_1.TenantResolutionStrategy.USER)) {
        const userTenantId = (_a = ctx.user) === null || _a === void 0 ? void 0 : _a.tenantId;
        if (userTenantId) {
            return userTenantId;
        }
    }
    // header
    if (isAllowed(types_1.TenantResolutionStrategy.HEADER)) {
        const headerTenantId = ctx.request.headers[constants_1.Header.TENANT_ID];
        if (headerTenantId) {
            return headerTenantId;
        }
    }
    // query param
    if (isAllowed(types_1.TenantResolutionStrategy.QUERY)) {
        const queryTenantId = ctx.request.query.tenantId;
        if (queryTenantId) {
            return queryTenantId;
        }
    }
    // subdomain
    if (isAllowed(types_1.TenantResolutionStrategy.SUBDOMAIN)) {
        // e.g. budibase.app or local.com:10000
        const platformHost = new URL(environment_1.default.PLATFORM_URL).host.split(":")[0];
        // e.g. tenant.budibase.app or tenant.local.com
        const requestHost = ctx.host;
        // parse the tenant id from the difference
        if (requestHost.includes(platformHost)) {
            const tenantId = requestHost.substring(0, requestHost.indexOf(`.${platformHost}`));
            if (tenantId) {
                return tenantId;
            }
        }
    }
    // path
    if (isAllowed(types_1.TenantResolutionStrategy.PATH)) {
        // params - have to parse manually due to koa-router not run yet
        const match = ctx.matched.find((m) => !!m.paramNames.find((p) => p.name === "tenantId"));
        // get the raw path url - without any query params
        const ctxUrl = ctx.originalUrl;
        let url;
        if (ctxUrl.includes("?")) {
            url = ctxUrl.split("?")[0];
        }
        else {
            url = ctxUrl;
        }
        if (match) {
            const params = match.params(url, match.captures(url), {});
            if (params.tenantId) {
                return params.tenantId;
            }
        }
    }
    if (!opts.allowNoTenant) {
        ctx.throw(403, "Tenant id not set");
    }
    return null;
};
exports.getTenantIDFromCtx = getTenantIDFromCtx;
//# sourceMappingURL=tenancy.js.map