import { Screen, Role as RoleDoc } from "@budibase/types";
export declare const BUILTIN_ROLE_IDS: {
    ADMIN: string;
    POWER: string;
    BASIC: string;
    PUBLIC: string;
};
export declare class Role implements RoleDoc {
    _id: string;
    _rev?: string;
    name: string;
    permissionId: string;
    inherits?: string;
    permissions: {};
    constructor(id: string, name: string, permissionId: string);
    addInheritance(inherits: string): this;
}
export declare function getBuiltinRoles(): {
    [key: string]: RoleDoc;
};
export declare const BUILTIN_ROLE_ID_ARRAY: string[];
export declare const BUILTIN_ROLE_NAME_ARRAY: string[];
export declare function isBuiltin(role?: string): boolean;
/**
 * Works through the inheritance ranks to see how far up the builtin stack this ID is.
 */
export declare function builtinRoleToNumber(id?: string): number;
/**
 * Converts any role to a number, but has to be async to get the roles from db.
 */
export declare function roleToNumber(id?: string): Promise<number>;
/**
 * Returns whichever builtin roleID is lower.
 */
export declare function lowerBuiltinRoleID(roleId1?: string, roleId2?: string): string;
/**
 * Gets the role object, this is mainly useful for two purposes, to check if the level exists and
 * to check if the role inherits any others.
 * @param {string|null} roleId The level ID to lookup.
 * @returns {Promise<Role|object|null>} The role object, which may contain an "inherits" property.
 */
export declare function getRole(roleId?: string): Promise<RoleDoc | undefined>;
/**
 * Returns an ordered array of the user's inherited role IDs, this can be used
 * to determine if a user can access something that requires a specific role.
 * @param {string} userRoleId The user's role ID, this can be found in their access token.
 * @param {object} opts Various options, such as whether to only retrieve the IDs (default true).
 * @returns {Promise<string[]|object[]>} returns an ordered array of the roles, with the first being their
 * highest level of access and the last being the lowest level.
 */
export declare function getUserRoleHierarchy(userRoleId?: string, opts?: {
    idOnly: boolean;
}): Promise<RoleDoc[] | (string | undefined)[]>;
export declare function checkForRoleResourceArray(rolePerms: {
    [key: string]: string[];
}, resourceId: string): {
    [key: string]: string[];
};
/**
 * Given an app ID this will retrieve all of the roles that are currently within that app.
 * @return {Promise<object[]>} An array of the role objects that were found.
 */
export declare function getAllRoles(appId?: string): Promise<any>;
/**
 * This retrieves the required role for a resource
 * @param permLevel The level of request
 * @param resourceId The resource being requested
 * @param subResourceId The sub resource being requested
 * @return {Promise<{permissions}|Object>} returns the permissions required to access.
 */
export declare function getRequiredResourceRole(permLevel: string, { resourceId, subResourceId }: {
    resourceId?: string;
    subResourceId?: string;
}): Promise<any[]>;
export declare class AccessController {
    userHierarchies: {
        [key: string]: string[];
    };
    constructor();
    hasAccess(tryingRoleId?: string, userRoleId?: string): Promise<boolean>;
    checkScreensAccess(screens: Screen[], userRoleId: string): Promise<Screen[]>;
    checkScreenAccess(screen: Screen, userRoleId: string): Promise<Screen | null>;
}
/**
 * Adds the "role_" for builtin role IDs which are to be written to the DB (for permissions).
 */
export declare function getDBRoleID(roleId?: string): string;
/**
 * Remove the "role_" from builtin role IDs that have been written to the DB (for permissions).
 */
export declare function getExternalRoleID(roleId?: string): string | undefined;
