"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getExternalRoleID = exports.getDBRoleID = exports.AccessController = exports.getRequiredResourceRole = exports.getAllRoles = exports.checkForRoleResourceArray = exports.getUserRoleHierarchy = exports.getRole = exports.lowerBuiltinRoleID = exports.roleToNumber = exports.builtinRoleToNumber = exports.isBuiltin = exports.BUILTIN_ROLE_NAME_ARRAY = exports.BUILTIN_ROLE_ID_ARRAY = exports.getBuiltinRoles = exports.Role = exports.BUILTIN_ROLE_IDS = void 0;
const permissions_1 = require("./permissions");
const db_1 = require("../db");
const context_1 = require("../context");
const db_2 = require("../db");
const { cloneDeep } = require("lodash/fp");
exports.BUILTIN_ROLE_IDS = {
    ADMIN: "ADMIN",
    POWER: "POWER",
    BASIC: "BASIC",
    PUBLIC: "PUBLIC",
};
const BUILTIN_IDS = Object.assign(Object.assign({}, exports.BUILTIN_ROLE_IDS), { BUILDER: "BUILDER" });
// exclude internal roles like builder
const EXTERNAL_BUILTIN_ROLE_IDS = [
    BUILTIN_IDS.ADMIN,
    BUILTIN_IDS.POWER,
    BUILTIN_IDS.BASIC,
    BUILTIN_IDS.PUBLIC,
];
class Role {
    constructor(id, name, permissionId) {
        this.permissions = {};
        this._id = id;
        this.name = name;
        this.permissionId = permissionId;
    }
    addInheritance(inherits) {
        this.inherits = inherits;
        return this;
    }
}
exports.Role = Role;
const BUILTIN_ROLES = {
    ADMIN: new Role(BUILTIN_IDS.ADMIN, "Admin", permissions_1.BuiltinPermissionID.ADMIN).addInheritance(BUILTIN_IDS.POWER),
    POWER: new Role(BUILTIN_IDS.POWER, "Power", permissions_1.BuiltinPermissionID.POWER).addInheritance(BUILTIN_IDS.BASIC),
    BASIC: new Role(BUILTIN_IDS.BASIC, "Basic", permissions_1.BuiltinPermissionID.WRITE).addInheritance(BUILTIN_IDS.PUBLIC),
    PUBLIC: new Role(BUILTIN_IDS.PUBLIC, "Public", permissions_1.BuiltinPermissionID.PUBLIC),
    BUILDER: new Role(BUILTIN_IDS.BUILDER, "Builder", permissions_1.BuiltinPermissionID.ADMIN),
};
function getBuiltinRoles() {
    return cloneDeep(BUILTIN_ROLES);
}
exports.getBuiltinRoles = getBuiltinRoles;
exports.BUILTIN_ROLE_ID_ARRAY = Object.values(BUILTIN_ROLES).map(role => role._id);
exports.BUILTIN_ROLE_NAME_ARRAY = Object.values(BUILTIN_ROLES).map(role => role.name);
function isBuiltin(role) {
    return exports.BUILTIN_ROLE_ID_ARRAY.some(builtin => role === null || role === void 0 ? void 0 : role.includes(builtin));
}
exports.isBuiltin = isBuiltin;
/**
 * Works through the inheritance ranks to see how far up the builtin stack this ID is.
 */
function builtinRoleToNumber(id) {
    if (!id) {
        return 0;
    }
    const builtins = getBuiltinRoles();
    const MAX = Object.values(builtins).length + 1;
    if (id === BUILTIN_IDS.ADMIN || id === BUILTIN_IDS.BUILDER) {
        return MAX;
    }
    let role = builtins[id], count = 0;
    do {
        if (!role) {
            break;
        }
        role = builtins[role.inherits];
        count++;
    } while (role !== null);
    return count;
}
exports.builtinRoleToNumber = builtinRoleToNumber;
/**
 * Converts any role to a number, but has to be async to get the roles from db.
 */
function roleToNumber(id) {
    return __awaiter(this, void 0, void 0, function* () {
        if (isBuiltin(id)) {
            return builtinRoleToNumber(id);
        }
        const hierarchy = (yield getUserRoleHierarchy(id));
        for (let role of hierarchy) {
            if (isBuiltin(role === null || role === void 0 ? void 0 : role.inherits)) {
                return builtinRoleToNumber(role.inherits) + 1;
            }
        }
        return 0;
    });
}
exports.roleToNumber = roleToNumber;
/**
 * Returns whichever builtin roleID is lower.
 */
function lowerBuiltinRoleID(roleId1, roleId2) {
    if (!roleId1) {
        return roleId2;
    }
    if (!roleId2) {
        return roleId1;
    }
    return builtinRoleToNumber(roleId1) > builtinRoleToNumber(roleId2)
        ? roleId2
        : roleId1;
}
exports.lowerBuiltinRoleID = lowerBuiltinRoleID;
/**
 * Gets the role object, this is mainly useful for two purposes, to check if the level exists and
 * to check if the role inherits any others.
 * @param {string|null} roleId The level ID to lookup.
 * @returns {Promise<Role|object|null>} The role object, which may contain an "inherits" property.
 */
function getRole(roleId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (!roleId) {
            return undefined;
        }
        let role = {};
        // built in roles mostly come from the in-code implementation,
        // but can be extended by a doc stored about them (e.g. permissions)
        if (isBuiltin(roleId)) {
            role = cloneDeep(Object.values(BUILTIN_ROLES).find(role => role._id === roleId));
        }
        try {
            const db = (0, context_1.getAppDB)();
            const dbRole = yield db.get(getDBRoleID(roleId));
            role = Object.assign(role, dbRole);
            // finalise the ID
            role._id = getExternalRoleID(role._id);
        }
        catch (err) {
            // only throw an error if there is no role at all
            if (Object.keys(role).length === 0) {
                throw err;
            }
        }
        return role;
    });
}
exports.getRole = getRole;
/**
 * Simple function to get all the roles based on the top level user role ID.
 */
function getAllUserRoles(userRoleId) {
    return __awaiter(this, void 0, void 0, function* () {
        // admins have access to all roles
        if (userRoleId === BUILTIN_IDS.ADMIN) {
            return getAllRoles();
        }
        let currentRole = yield getRole(userRoleId);
        let roles = currentRole ? [currentRole] : [];
        let roleIds = [userRoleId];
        // get all the inherited roles
        while (currentRole &&
            currentRole.inherits &&
            roleIds.indexOf(currentRole.inherits) === -1) {
            roleIds.push(currentRole.inherits);
            currentRole = yield getRole(currentRole.inherits);
            if (currentRole) {
                roles.push(currentRole);
            }
        }
        return roles;
    });
}
/**
 * Returns an ordered array of the user's inherited role IDs, this can be used
 * to determine if a user can access something that requires a specific role.
 * @param {string} userRoleId The user's role ID, this can be found in their access token.
 * @param {object} opts Various options, such as whether to only retrieve the IDs (default true).
 * @returns {Promise<string[]|object[]>} returns an ordered array of the roles, with the first being their
 * highest level of access and the last being the lowest level.
 */
function getUserRoleHierarchy(userRoleId, opts = { idOnly: true }) {
    return __awaiter(this, void 0, void 0, function* () {
        // special case, if they don't have a role then they are a public user
        const roles = yield getAllUserRoles(userRoleId);
        return opts.idOnly ? roles.map(role => role._id) : roles;
    });
}
exports.getUserRoleHierarchy = getUserRoleHierarchy;
// this function checks that the provided permissions are in an array format
// some templates/older apps will use a simple string instead of array for roles
// convert the string to an array using the theory that write is higher than read
function checkForRoleResourceArray(rolePerms, resourceId) {
    if (rolePerms && !Array.isArray(rolePerms[resourceId])) {
        const permLevel = rolePerms[resourceId];
        rolePerms[resourceId] = [permLevel];
        if (permLevel === permissions_1.PermissionLevel.WRITE) {
            rolePerms[resourceId].push(permissions_1.PermissionLevel.READ);
        }
    }
    return rolePerms;
}
exports.checkForRoleResourceArray = checkForRoleResourceArray;
/**
 * Given an app ID this will retrieve all of the roles that are currently within that app.
 * @return {Promise<object[]>} An array of the role objects that were found.
 */
function getAllRoles(appId) {
    return __awaiter(this, void 0, void 0, function* () {
        if (appId) {
            return (0, db_2.doWithDB)(appId, internal);
        }
        else {
            let appDB;
            try {
                appDB = (0, context_1.getAppDB)();
            }
            catch (error) {
                // We don't have any apps, so we'll just use the built-in roles
            }
            return internal(appDB);
        }
        function internal(db) {
            return __awaiter(this, void 0, void 0, function* () {
                let roles = [];
                if (db) {
                    const body = yield db.allDocs((0, db_1.getRoleParams)(null, {
                        include_docs: true,
                    }));
                    roles = body.rows.map((row) => row.doc);
                }
                const builtinRoles = getBuiltinRoles();
                // need to combine builtin with any DB record of them (for sake of permissions)
                for (let builtinRoleId of EXTERNAL_BUILTIN_ROLE_IDS) {
                    const builtinRole = builtinRoles[builtinRoleId];
                    const dbBuiltin = roles.filter(dbRole => getExternalRoleID(dbRole._id) === builtinRoleId)[0];
                    if (dbBuiltin == null) {
                        roles.push(builtinRole || builtinRoles.BASIC);
                    }
                    else {
                        // remove role and all back after combining with the builtin
                        roles = roles.filter(role => role._id !== dbBuiltin._id);
                        dbBuiltin._id = getExternalRoleID(dbBuiltin._id);
                        roles.push(Object.assign(builtinRole, dbBuiltin));
                    }
                }
                // check permissions
                for (let role of roles) {
                    if (!role.permissions) {
                        continue;
                    }
                    for (let resourceId of Object.keys(role.permissions)) {
                        role.permissions = checkForRoleResourceArray(role.permissions, resourceId);
                    }
                }
                return roles;
            });
        }
    });
}
exports.getAllRoles = getAllRoles;
/**
 * This retrieves the required role for a resource
 * @param permLevel The level of request
 * @param resourceId The resource being requested
 * @param subResourceId The sub resource being requested
 * @return {Promise<{permissions}|Object>} returns the permissions required to access.
 */
function getRequiredResourceRole(permLevel, { resourceId, subResourceId }) {
    return __awaiter(this, void 0, void 0, function* () {
        const roles = yield getAllRoles();
        let main = [], sub = [];
        for (let role of roles) {
            // no permissions, ignore it
            if (!role.permissions) {
                continue;
            }
            const mainRes = resourceId ? role.permissions[resourceId] : undefined;
            const subRes = subResourceId ? role.permissions[subResourceId] : undefined;
            if (mainRes && mainRes.indexOf(permLevel) !== -1) {
                main.push(role._id);
            }
            else if (subRes && subRes.indexOf(permLevel) !== -1) {
                sub.push(role._id);
            }
        }
        // for now just return the IDs
        return main.concat(sub);
    });
}
exports.getRequiredResourceRole = getRequiredResourceRole;
class AccessController {
    constructor() {
        this.userHierarchies = {};
    }
    hasAccess(tryingRoleId, userRoleId) {
        return __awaiter(this, void 0, void 0, function* () {
            // special cases, the screen has no role, the roles are the same or the user
            // is currently in the builder
            if (tryingRoleId == null ||
                tryingRoleId === "" ||
                tryingRoleId === userRoleId ||
                tryingRoleId === BUILTIN_IDS.BUILDER ||
                userRoleId === BUILTIN_IDS.BUILDER) {
                return true;
            }
            let roleIds = userRoleId ? this.userHierarchies[userRoleId] : null;
            if (!roleIds && userRoleId) {
                roleIds = (yield getUserRoleHierarchy(userRoleId, {
                    idOnly: true,
                }));
                this.userHierarchies[userRoleId] = roleIds;
            }
            return (roleIds === null || roleIds === void 0 ? void 0 : roleIds.indexOf(tryingRoleId)) !== -1;
        });
    }
    checkScreensAccess(screens, userRoleId) {
        return __awaiter(this, void 0, void 0, function* () {
            let accessibleScreens = [];
            // don't want to handle this with Promise.all as this would mean all custom roles would be
            // retrieved at same time, it is likely a custom role will be re-used and therefore want
            // to work in sync for performance save
            for (let screen of screens) {
                const accessible = yield this.checkScreenAccess(screen, userRoleId);
                if (accessible) {
                    accessibleScreens.push(accessible);
                }
            }
            return accessibleScreens;
        });
    }
    checkScreenAccess(screen, userRoleId) {
        return __awaiter(this, void 0, void 0, function* () {
            const roleId = screen && screen.routing ? screen.routing.roleId : undefined;
            if (yield this.hasAccess(roleId, userRoleId)) {
                return screen;
            }
            return null;
        });
    }
}
exports.AccessController = AccessController;
/**
 * Adds the "role_" for builtin role IDs which are to be written to the DB (for permissions).
 */
function getDBRoleID(roleId) {
    if (roleId === null || roleId === void 0 ? void 0 : roleId.startsWith(db_1.DocumentType.ROLE)) {
        return roleId;
    }
    return (0, db_1.generateRoleID)(roleId);
}
exports.getDBRoleID = getDBRoleID;
/**
 * Remove the "role_" from builtin role IDs that have been written to the DB (for permissions).
 */
function getExternalRoleID(roleId) {
    // for built-in roles we want to remove the DB role ID element (role_)
    if ((roleId === null || roleId === void 0 ? void 0 : roleId.startsWith(db_1.DocumentType.ROLE)) && isBuiltin(roleId)) {
        return roleId.split(`${db_1.DocumentType.ROLE}${db_1.SEPARATOR}`)[1];
    }
    return roleId;
}
exports.getExternalRoleID = getExternalRoleID;
//# sourceMappingURL=roles.js.map